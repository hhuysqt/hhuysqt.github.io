<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>uc-PC[4] 小议“设备树” | hhuysqt</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="ucpc">
    <meta name="description" content="讲设备树的文章不少。以下是一些挺有意思的文章：  蜗窝科技的博客紧扣Linux内核来讲设备树的来历与用法； Thomas Petazzoni是Bootlin公司（以前叫Free Electrons，一家很有水平的专注Linux的法国公司）的CTO，他写过一份讲义叫《傻瓜都懂的设备树》，详细地介绍了设备树的语法与Linux内核中现实的用例； device tree kernel internals这">
<meta name="keywords" content="ucpc">
<meta property="og:type" content="article">
<meta property="og:title" content="uc-PC[4] 小议“设备树”">
<meta property="og:url" content="https://hhuysqt.github.io/ucpc4/index.html">
<meta property="og:site_name" content="hhuysqt">
<meta property="og:description" content="讲设备树的文章不少。以下是一些挺有意思的文章：  蜗窝科技的博客紧扣Linux内核来讲设备树的来历与用法； Thomas Petazzoni是Bootlin公司（以前叫Free Electrons，一家很有水平的专注Linux的法国公司）的CTO，他写过一份讲义叫《傻瓜都懂的设备树》，详细地介绍了设备树的语法与Linux内核中现实的用例； device tree kernel internals这">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc4/block-pc.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc4/dts-basic.jpeg">
<meta property="og:updated_time" content="2019-04-27T18:59:05.773Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="uc-PC[4] 小议“设备树”">
<meta name="twitter:description" content="讲设备树的文章不少。以下是一些挺有意思的文章：  蜗窝科技的博客紧扣Linux内核来讲设备树的来历与用法； Thomas Petazzoni是Bootlin公司（以前叫Free Electrons，一家很有水平的专注Linux的法国公司）的CTO，他写过一份讲义叫《傻瓜都懂的设备树》，详细地介绍了设备树的语法与Linux内核中现实的用例； device tree kernel internals这">
<meta name="twitter:image" content="https://hhuysqt.github.io/ucpc4/block-pc.jpeg">
    
        <link rel="alternate" type="application/atom+xml" title="hhuysqt" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/m.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

  <!-- highlight.js代码高亮主题 css 引入-->
  <link rel="stylesheet" href="/plugins/highlight/styles/github.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<!--
  <script src="/plugins/highlight/highlight.pack.js"></script>
-->
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- highlight.js代码高亮主题 css 引入-->
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">hhuysqt</h5>
          <a href="mailto:1020988872@qq.com" title="1020988872@qq.com" class="mail">1020988872@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                所有文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                索引
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/hhuysqt" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.zhihu.com/people/hhuysqt/activities" target="_blank" >
                <i class="icon icon-lg icon-search-plus"></i>
                知乎
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">uc-PC[4] 小议“设备树”</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">uc-PC[4] 小议“设备树”</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-03-01T07:33:52.000Z" itemprop="datePublished" class="page-time">
  2018-03-01
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>目录</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C语言实现面向对象的概念"><span class="post-toc-number">1.</span> <span class="post-toc-text">C语言实现面向对象的概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#封装"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">封装</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#继承"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多态"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">多态</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#举个例子：内核中STM32的串口驱动"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">举个例子：内核中STM32的串口驱动</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#container-of（）"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">container-of（）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Linux设备驱动模型"><span class="post-toc-number">2.</span> <span class="post-toc-text">Linux设备驱动模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#著名的设备、驱动、总线三剑客"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">著名的设备、驱动、总线三剑客</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#平台设备、平台驱动、平台总线"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">平台设备、平台驱动、平台总线</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何刻画一个设备？"><span class="post-toc-number">3.</span> <span class="post-toc-text">如何刻画一个设备？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#可选用的语言"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">可选用的语言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#设备树基本语法"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">设备树基本语法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#设备树对应到驱动程序"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">设备树对应到驱动程序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#“设备树绑定”，以及“设备树绑定”的文档"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">“设备树绑定”，以及“设备树绑定”的文档</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-ucpc4"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">uc-PC[4] 小议“设备树”</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-03-01 15:33:52" datetime="2018-03-01T07:33:52.000Z"  itemprop="datePublished">2018-03-01</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>讲设备树的文章不少。以下是一些挺有意思的文章：</p>
<ul>
<li><a href="http://www.wowotech.net/device_model/why-dt.html" target="_blank" rel="noopener">蜗窝科技的博客</a>紧扣Linux内核来讲设备树的来历与用法；</li>
<li>Thomas Petazzoni是Bootlin公司（以前叫Free Electrons，一家很有水平的专注Linux的法国公司）的CTO，他写过一份讲义叫<a href="https://bootlin.com/pub/conferences/2013/elce/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf" target="_blank" rel="noopener">《傻瓜都懂的设备树》</a>，详细地介绍了设备树的语法与Linux内核中现实的用例；</li>
<li><a href="https://elinux.org/images/0/0c/Rowand--devicetree_kernel_internals.pdf" target="_blank" rel="noopener">device tree kernel internals</a>这篇报告更加详细地描述了设备树的语法、编译过程，并分析了设备树展开过程的一些源码；</li>
<li>还是Thomas Petazzoni，他在2015年的ELC会议上抱怨说：<a href="https://events.static.linuxfound.org/sites/events/files/slides/petazzoni-dt-as-stable-abi-fairy-tale.pdf" target="_blank" rel="noopener">不同内核里设备树接口要保持可移植性，这简直是个神话</a>；</li>
</ul>
<p>很多介绍设备树的文章都会开门见山地介绍设备树的各种概念，然后罗列出设备树的语法。<strong>不过很少有人会从头到尾讲透驱动程序和设备树，然后旗帜鲜明地指出，设备树描述的就是平台设备（platform_device），或许他们默认了你已经懂得那些前提知识</strong>。以下记录了我的一些思考，尝试从<code>面向对象</code>的角度去切入。</p>
<p><em>（手机请横屏看代码）</em><br><a id="more"></a></p>
<h3 id="C语言实现面向对象的概念"><a href="#C语言实现面向对象的概念" class="headerlink" title="C语言实现面向对象的概念"></a>C语言实现面向对象的概念</h3><p>“面向对象”与其说是一种程序设计方法（方法论），不如说是一种思维（世界观）。我的一位老师粗略估计了一下：如果你用面向过程的思维去写代码维护代码，顶多能弄50万行；而用面向对象的思维的话，还不知道上限是多少。Windows XP泄露出来的源码就有4500万行了，前段时间泄露出来的Win10源码大小有12TB，一般人下下来都存不下。</p>
<p>如今Linux内核也有接近2000万行代码，uboot都有80万行代码了，而它们都用C语言写成，想必是用了不同于面向过程的思维和技巧了。</p>
<p>C语言可以实现相当多的面向对象的概念，有相当多的书籍讲述了object oriented C（OOC），关键就是使用struct去封装成员对象和函数指针，函数指针就是方法；指针很自由，可以表达各种概念。其中，<a href="http://customers.hbci.com/~rpopp/Books/Object-oriented%20Programming%20With%20ANSI-C.pdf" target="_blank" rel="noopener"><strong><em><code>Object-oriented Programming With ANSI-C</code></em></strong></a>这本书里的实现方法相当优雅，它并不局限于struct，而且它将void指针玩出花来了，可以说离仅使用基本面向对象语法的C++就差个class关键字了。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>声明一个<code>struct</code>就是声明一个<code>类</code>。定义一个struct就是将类<code>实例化</code>为<code>对象</code>。</p>
<p>一个类里面声明有<code>属性</code>和<code>方法</code>。使用struct的话，属性就照常写，方法就写为<code>函数指针</code>。比方说在<strong>一个头文件里</strong>声明foo类，里面有一个成员叫bar，然后有一个方法get_bar，返回实际对象里的bar值：</p>
<pre><code class="c">struct foo {
    // 属性
    int bar;
    // 接口
    int (*get_bar)(struct foo*);
};
</code></pre>
<p>get_bar()函数一般在<strong>某一个C文件里</strong>实现为static函数：</p>
<pre><code class="c">static int my_get_bar(struct foo* f)
{
    return f-&gt;bar;
}
</code></pre>
<p>然后，在<strong>同一个C文件里面</strong>实现<strong>全局可见</strong>的<code>构造函数</code>：</p>
<pre><code class="c">struct foo* new_foo(void)
{
    struct foo* f = (struct foo*)
    malloc(sizeof(struct foo));
    if (!f)
        return NULL;
    // 然后可有一些默认初始化
    f-&gt;bar = 0;
    // 还要初始化接口函数指针！
    f-&gt;get_bar = my_get_bar;
    return f;
}
</code></pre>
<p>最后，这样使用这个类：</p>
<pre><code class="c">// new一个对象：
struct foo* f = new_foo();
// 通过接口访问该对象
int the_bar = f-&gt;get_bar(f);
// 删除这个对象
free(f);
</code></pre>
<p>上述的实现方法展示了最基础的类的封装。接口除了基本的getter和setter之外，<code>构造函数</code>和<code>析构函数</code>也可以定义为函数指针。这时候可以写出通用的new和delete函数统一管理所有的类。Linux内核里有多种宏可以达到new和delete的目的，比方说可以通过<code>MODULE_init()</code>宏修饰构造函数，通过<code>MODULE_exit()</code>宏修饰析构函数。</p>
<p><code>封装</code>不仅仅是属性和方法的整合，还包括要<code>数据隐藏</code>：只能通过一些接口来访问一个对象的属性。鉴于C语言缺乏private等语法，数据隐藏有以下方法：</p>
<ul>
<li>像上面提到的<a href="http://customers.hbci.com/~rpopp/Books/Object-oriented%20Programming%20With%20ANSI-C.pdf" target="_blank" rel="noopener">OO ANSI-C</a>那本书那样使用void指针。void指针也称自由指针，这样的话struct里面的东西就完全private了，只能通过接口来访问。</li>
<li>或者，靠程序员的自律（Linux内核就是这样干的）</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>（继承也称泛化。“A<code>泛化</code>为B”，跟“B<code>继承</code>了A”是一个意思。）</p>
<p>现在假设另一个类foo2<code>继承</code>了foo，可以这样声明：</p>
<pre><code class="c">struct foo2 {
    struct foo *super;
};
</code></pre>
<p>然后foo2的构造函数如下：</p>
<pre><code class="c">struct foo2 *new_foo2(void)
{
    struct foo2 *f2 = (struct foo2)
        malloc(sizeof(struct foo2));
    if (!f2)
        return NULL;
    // 构造父类
    f2-&gt;super = new_foo();
    if (!f2-&gt;super) {
        free(f2);
        return NULL;
    }
    return f2;
}
</code></pre>
<p>如果需要访问foo2继承自foo的属性，则通过foo2-&gt;super的接口来访问。也可以在foo2里面重新造轮子，先做一些自己的东西，然后再调用super的方法（Linux内核里面经常这样做）。</p>
<p><strong>可见，要实现继承，一般在子类里面定义一个父类（或它的指针）</strong>。如果是<code>多继承</code>，那就多构造几个父类。值得注意的是，要逐个构造不同的类时，只要有一个类没有成功构造，之前所成功构造的类都得析构。这样的话会写得很麻烦，于是Linux内核推荐使用<code>goto</code>语句：</p>
<pre><code class="c">    struct f1 *f1 = new_f1();
    if (!f1) goto NULL_F1;
    struct f2 *f2 = new_f2();
    if (!f2) goto NULL_F2;
    struct f3 *f3 = new_f3();
    if (!f3) goto NULL_F3;
    ...
    // 成功
    return foobar;

    // 各种程度的失败
NULL_F3:
    free(f2);
NULL_F2:
    free(f1);
NULL_F1:
    return NULL;
</code></pre>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>因为使用了函数指针，指针非常自由，因而可以将其替换为任何合适的函数。于是子类可以<code>重写（overridding）</code>父类的方法，这体现了<code>多态</code>。</p>
<p><code>重载（overloading）</code>是一种语言特性，然而C语言并不能提供这种特性，所以在需要重载的地方使用多个函数。比方说Linux的<code>wait3()</code>、<code>wait4()</code>等一系列wait系统调用，wait3表示它有3个参数，wait4表示它有4个参数。。。</p>
<h4 id="举个例子：内核中STM32的串口驱动"><a href="#举个例子：内核中STM32的串口驱动" class="headerlink" title="举个例子：内核中STM32的串口驱动"></a>举个例子：内核中STM32的串口驱动</h4><p>其实不只是STM32，其他片子的串口都实现为一个tty驱动。tty不只有串口终端，还有framebuffer终端、网络终端等等，它们都统一为一个相当复杂的tty架构，不过下面仅简单探讨一些类的继承关系。</p>
<p>它涉及到<code>tty_driver</code>、<code>uart_port</code>、<code>stm32_port</code>这3个类，它们这样定义：</p>
<p><a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/tty_driver.h#L296" target="_blank" rel="noopener">include/linux/tty_driver.h</a></p>
<pre><code class="c">struct tty_driver {
    ...
    const struct tty_operations *ops;
    ...
};
</code></pre>
<p><a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/serial_core.h#L117" target="_blank" rel="noopener">include/linux/serial_core.h</a></p>
<pre><code class="c">struct uart_port {
    ...
    const struct uart_ops *ops;
    ...
    struct tty_driver *tty_driver;
};
</code></pre>
<p><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/stm32-usart.h#L214" target="_blank" rel="noopener">drivers/tty/serial/stm32-usart.h</a></p>
<pre><code class="c">struct stm32_port {
    struct uart_port port;
    ...
};
</code></pre>
<p>其中，tty_operations和uart_ops都是函数指针表。从上面代码片段可以看出，uart_port继承了tty_driver，stm32_port继承了uart_port。</p>
<p>值得注意的是，tty_operations里的函数，不实现在tty相关的c文件里，而实现在serial相关的c文件里；uart_port的函数，不实现在serial相关c文件里，而实现在每一个芯片的串口驱动的c文件里面。这说明前两个类是<strong>抽象类</strong>。</p>
<p>假设我们要发送数据。tty_operations里有个<code>write()</code>，<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/serial_core.c#L546" target="_blank" rel="noopener">drivers/tty/serial/serial_core.c</a>里将其实现为<code>uart_write()</code>；它将数据填入缓冲区后，最终调用了uart_ops的<code>start_tx()</code>，<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/stm32-usart.c#L393" target="_blank" rel="noopener">drivers/tty/serial/stm32-usart.c</a>里将其实现为<code>stm32_start_tx()</code>，最终依靠DMA或者轮询（polling IO）的方式将数据写入串口数据寄存器中。</p>
<p>还应注意到的是，它们构造父类的风格并不统一：uart_port想要继承tty_driver，则通过<code>alloc_tty_driver()</code>来new一个父类，然后<code>tty_set_operations()</code>等建立与父类的联系，最后<code>tty_register_driver()</code>注册驱动函数。而stm32_port要继承uart_port就直接在子类内部定义一个父类对象就完事了。</p>
<h4 id="container-of（）"><a href="#container-of（）" class="headerlink" title="container-of（）"></a>container-of（）</h4><p>写驱动时常需要继承一些已有的类，比方说一个字符设备驱动继承cdev，或者如1.4的例子stm32串口设备继承uart_port。C语言里父类定义在子类内部，而内核的基础设施传参时只将父类对象的指针传进来，但是驱动程序要用到的又是子类对象。所以问题就是，如何通过父类对象找到子类对象。</p>
<p>有一个解决办法是，将父类定义为子类的<strong>第一个成员</strong>，这样的话就可以通过强制类型转换，直接得到子类。比如：</p>
<pre><code class="c">struct son {
    struct father father;
    ...
};
</code></pre>
<p>如果有一个指针<code>struct father *f</code>，而且知道它肯定是被继承为son的对象，那么这个指针可以强转为<code>struct son*</code>指针。</p>
<p>但是多继承的情况就无法这样做了；而且只能将父类定义为第一个成员，简直太死板了。于是Linux内核里面定义了一个<code>contailer_of()</code>宏，通过结构体成员的地址找到整个结构体的地址。定义在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/kernel.h#L858" target="_blank" rel="noopener">include/linux/kernel.h</a>：</p>
<pre><code class="c">#define container_of(ptr, type, member) ({   \
    void *__mptr = (void *)(ptr); \
    ((type *)(__mptr - offsetof(type, member))); })
</code></pre>
<p>意思是，该成员的地址减去其在结构体中的偏移量，就是包含它的那个结构体的地址。其中<code>offsetof()</code>宏定义在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/stddef.h" target="_blank" rel="noopener">include/linux/stddef.h</a>：</p>
<pre><code>#ifdef __compiler_offsetof
#define offsetof(TYPE, MEMBER)    __compiler_offsetof(TYPE, MEMBER)
#else
#define offsetof(TYPE, MEMBER)    ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)
#endif
</code></pre><p>gcc预定义了<code>__compiler_offsetof()</code>宏，可以直接用。如果编译器没有这个手段的话，那么就将其定义为<strong>在0地址处的那个结构体的那个成员的偏移量</strong>。。。</p>
<p>值得一提的是，gcc对C语言做了大量的扩展，比方说它允许花括号括着的<code>块结构</code>有返回值：注意到那个圆括号花括号的组合<code>({...})</code>，返回的是块结构中最后一句话的返回值。另外它还允许在块结构中定义函数，于是gcc的<a href="https://www.codeproject.com/tips/614570/lambda-in-c-gcc" target="_blank" rel="noopener">C语言可以神奇地写出lamda函数</a>。。。</p>
<h3 id="Linux设备驱动模型"><a href="#Linux设备驱动模型" class="headerlink" title="Linux设备驱动模型"></a>Linux设备驱动模型</h3><p>在2.5版本的内核中集中精力重新设计了设备驱动程序的架构，提出了一个精心设计的<code>设备模型</code>。想要实现的效果便是：如果内核发现一个设备，而且内核中有其驱动，那么内核就可以把该设备暴露到用户空间中，以待应用程序操作。而且引入sysfs，并以kobj作为sysfs里面每个对象的基类。</p>
<h4 id="著名的设备、驱动、总线三剑客"><a href="#著名的设备、驱动、总线三剑客" class="headerlink" title="著名的设备、驱动、总线三剑客"></a>著名的设备、驱动、总线三剑客</h4><p>外设通过总线挂到CPU上，整个系统看上去长这样（图自<a href="https://doc.lagout.org/operating%20system%20/linux/Essential%20Linux%20Device%20Drivers.pdf" target="_blank" rel="noopener"><em>essential linux device drivers</em></a>）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc4/block-pc.jpeg" alt="system" title="">
                </div>
                <div class="image-caption">system</div>
            </figure></p>
<p>经过抽象，引入<code>device</code>、<code>device_driver</code>、<code>bus_type</code>这三个类；现实世界中device通过bus挂载到CPU上，device通过bus_type与device_driver联系起来。它们都声明在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/device.h" target="_blank" rel="noopener">include/linux/device.h</a>中：</p>
<pre><code class="c">struct device {
    ...
    struct bus_type    *bus;
    struct device_driver *driver;
    ...
};

struct device_driver {
    ...
    /* 一堆函数指针 */
    ...
};

struct bus_type {
    ...
    /* 一堆函数指针 */
    ...
};
</code></pre>
<p>这三个类中最为复杂的是device类，另外两个类基本上是一些方法。下面罗列了它们一些简单的特性：</p>
<ul>
<li>device_driver和device都会注册到一个bus上。bus_type里面最重要的方法是<code>match()</code>，如果判断设备和驱动相匹配，将调用device_driver的<code>probe()</code>方法，交给device_driver来完成接下来的工作。</li>
<li>device_driver里的<code>probe()</code>方法也被称为驱动程序的入口，probe成功后设备将有一系列<code>file_operations</code>从而可以被应用程序访问，此时设备的实例就产生了。</li>
<li>device内有device指针和链表，让device之间形成一个树状结构去模拟现实系统中的情况；</li>
<li>device又有kobject，通过kobj的指针在<strong>sysfs</strong>里又形成一个树状结构；</li>
<li>device里还有of_node，对应到<strong>设备树</strong>上的节点。这又是一个树状结构；</li>
<li>device内有个struct class*，为了方便在sysfs将设备归类。</li>
</ul>
<p>device类集中了设备的属性，device_driver、bus_type等类集中了设备的操作；从面向对象的角度可以有数种解读，比如：</p>
<ul>
<li>device、device_driver、bus_type是相互独立的类；其中device依赖bus_type，device和device_driver之间是关联关系。这是一种合乎常理的理解，很多资料也从这个角度理解。</li>
<li>device是以device_driver、bus_type等为父类的<strong>多继承</strong>。要实例化一个device，先实例化父类driver和bus。这也是一个合理的解读角度。</li>
</ul>
<h4 id="平台设备、平台驱动、平台总线"><a href="#平台设备、平台驱动、平台总线" class="headerlink" title="平台设备、平台驱动、平台总线"></a>平台设备、平台驱动、平台总线</h4><p>PC上的设备大都接在PCI一类的总线上，可动态探索设备、动态分配地址空间、动态分配中断资源。这时总线的处理程序就可以动态生成device来与driver配对了。</p>
<p>但是对于像ARM这种将内存空间和设备空间统一编址的架构来说，很多设备并不挂载在可以动态探知设备的总线上，而是有固定的地址供CPU寻址。<strong>STM32所有外设都这样</strong>（当然也有不少ARM架构的SOC有PCI总线）。这些设备都叫<code>平台设备（platform device）</code>。为符合Linux设备模型，就专门造出了一个虚拟的总线叫<code>平台总线（platform bus)</code>，上面注册有平台设备与<code>平台驱动（platform driver）</code>。它们分别继承自device、bus_type、device_driver。</p>
<p>由于平台设备不能动态探知，所以内核应该事先知道这些设备，于是platform_device对象应该写死在内核里面。2.6.x内核里面就是这样干的。所以当年如果你要实现一个驱动，除了要实现platform_driver，还要在某一个地方定义一个static的platform_device（或者继承它的子类），然后在使用<code>MODULE_init()</code>宏修饰的构造函数里面注册driver和device（MODULE_init的工作方式是将一堆函数指针存到某一个section里，形成一个数组，以便内核初始化时候逐个调用）。</p>
<p>平台总线的match()方法，对比的是平台设备和平台驱动的<strong>name字段是否相同</strong>，以此来配对设备和驱动。比方说，我在一个地方定义一个设备：</p>
<pre><code class="c">static struct platform_device 
foo_device = {
    .name        = &quot;foo&quot;,
    ...
};
</code></pre>
<p>然后在另一个地方定义一个驱动：</p>
<pre><code class="c">static struct platform_driver 
foo_driver = {
    .driver    = {
        .name        = &quot;foo&quot;,
    };
    .probe = foo_probe,
    ...
};
</code></pre>
<p>在构造函数里面注册设备和驱动：</p>
<pre><code class="c">// 在一个地方添加设备
platform_add_devices(&amp;foo_device, 1);
...
// 在另一个地方添加驱动
platform_driver_register(&amp;foo_driver);
</code></pre>
<p>随后驱动中的foo_probe()函数将被调用。</p>
<p>有不少代码，driver定义在它驱动目录下的文件里，device或许又定义在板级初始化目录下的文件里面，显得相当随心所欲。如今内核中这种代码也还存在，比方说omap使用了<code>plat_nand</code>设备：<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/mtd/nand/plat_nand.c" target="_blank" rel="noopener">drivers/mtd/nand/plat_nand.c</a>里注册驱动，<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/mach-omap1/board-h2.c" target="_blank" rel="noopener">arch/arm/mach-omap1/board-h2.c</a>里面定义了nand flash的分区信息，并注册设备。</p>
<p>ARM架构片子浩如烟海，而且外设基本上都是平台设备，这导致内核里板级初始化部分相当混乱，充斥着长达数万行的静态声明的结构体和函数，又多又杂。这令Linus本人忍无可忍，终于<a href="https://lkml.org/lkml/2011/3/17/492" target="_blank" rel="noopener">在2011年3月17日将ARM社区臭骂一顿，斥其为痔疮（a f**king pain in the ass）</a>。经过激烈的讨论，ARM从内核3.x之后便引入<code>设备树</code>来代替代码里面的平台设备了。。。</p>
<h3 id="如何刻画一个设备？"><a href="#如何刻画一个设备？" class="headerlink" title="如何刻画一个设备？"></a>如何刻画一个设备？</h3><p>现在我们要用另一种机制来代替平台设备。它简单明了，并且运行时转化为平台设备。</p>
<p>一个设备就是一个<code>对象</code>，世间万物都是对象。每个对象拥有一系列<code>属性</code>，属性即是<code>名</code>和<code>值</code>的对应；现在<strong>不想声明类而直接把对象表达出来</strong>。</p>
<h4 id="可选用的语言"><a href="#可选用的语言" class="headerlink" title="可选用的语言"></a>可选用的语言</h4><p>假若我们要表达一个名字为”serial1”，波特率为115200的串口，当然现实世界的串口属性远不止这些，还有它寄存器组的地址、中断源、DMA通道、时钟源等等。</p>
<p>如果直接用c语言数据结构来表示的话，显然就要先声明一个类再实例化：</p>
<pre><code class="c">struct usart_struct {
    const char *name;
    unsigned baudrate;
}
usart = {
    .name = &quot;serial1&quot;,
    .baudrate = 115200,
};
</code></pre>
<p>因为设备实在太千奇百怪多种多样了，如果每一种芯片的外设都这么搞的话，那代码就相当臃肿了。其实不少语言都能直接<strong>随心所欲地</strong>定义对象，它们可有两种风格：</p>
<ul>
<li>标签式的风格，标签接标签，标签套标签。如XML：<pre><code class="xml">&lt;usart&gt;
  &lt;name&gt;serial1&lt;/name&gt;
  &lt;baudrate&gt;115200&lt;/baudrate&gt;
&lt;/usart&gt;
</code></pre>
</li>
<li>数据结构式的风格。如json：<pre><code class="json">{
&quot;usart&quot;: {
  &quot;name&quot;: &quot;serial1&quot;,
  &quot;baudrate&quot;: 115200
}
}
</code></pre>
</li>
</ul>
<p>其实，还真有一些工程的设备树就是json，<a href="https://github.com/xboot/xboot" target="_blank" rel="noopener">XBoot</a>就是这样。。。</p>
<p>Linux内核中，我们会用设备树来描述，其文件后缀是dts：</p>
<pre><code>/ {
    usart:serial1@0 {
        baudrate = &lt;115200&gt;;
    };
};
</code></pre><p>看上去像极了json，因为它们都是数据结构式的风格。其实内核编译dts之前先过一遍c预处理器，所以可以使用各种宏定义，包含头文件等等。</p>
<p>除了单纯刻画出对象的属性，还得表达不同对象之间的关系。对于硬件设备而言可以有以下的例子：</p>
<ul>
<li><code>串口</code>和<code>时钟管理器</code>这两个设备体现了<code>依赖关系（dependency）</code>：串口依赖于时钟管理器产生时钟，初始化串口之前必须初始化时钟，初始化完时钟之后串口一般就不必理会时钟了；</li>
<li><code>串口</code>和<code>串口对应的GPIO</code>体现了<code>聚合关系（aggregation）</code>：串口可以包含一些GPIO，但是这些GPIO不依赖串口而存在（或者说这些GPIO还可以用于其他的外设），初始化时并不强制要求谁先谁后；</li>
<li><code>串口</code>等一系列外设和<code>SOC芯片</code>体现了<code>组合关系（composition）</code>：一系列外设组合成为SOC芯片；</li>
<li><code>串口</code>和<code>DMA</code>这两个设备体现的是一种比较通用的<code>关联关系（association）</code>：它们是独立的两个设备，并且相互知道对方的存在；</li>
</ul>
<p>如果要表达<code>组合关系</code>这种强烈的整体和局部的关系，那么直接把小的一方定义在大的一方之内就行了。但是如果两个对象比较独立，它们之间的关系就没有整体和局部那么的强烈，那么就需要有一个表达<code>引用</code>的语法，即在一个对象中去引用另一个对象，此时单纯的XML或者json就表达不出来了；而dts就可以表达出来。</p>
<h4 id="设备树基本语法"><a href="#设备树基本语法" class="headerlink" title="设备树基本语法"></a>设备树基本语法</h4><p>一张图就够了：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc4/dts-basic.jpeg" alt="设备树基本语法" title="">
                </div>
                <div class="image-caption">设备树基本语法</div>
            </figure></p>
<p>关注点是，</p>
<ul>
<li>语句末要加分号</li>
<li>在哪里定义该节点的名字（Node name，在花括号之前，<strong>label之后</strong>）</li>
<li>在哪里定义该外设寄存器组的地址（Unit address，@符号）</li>
<li>属性名和属性值怎么定义（Property name和Property value，等于号来连接）</li>
<li>布尔属性（没有写值，仅表示这个属性声明与否）</li>
<li>数组怎么定义（a-string-list-property，用逗号分割的值）</li>
<li>一个属性有多个值该怎么定义（a-cell-property，尖括号中空格分隔的值）</li>
<li><strong>标号怎么定义（Label，节点名字之前，用冒号）</strong></li>
<li><strong>怎么引用别的节点（phandel，&amp;符号）</strong></li>
</ul>
<p>dts文件里面的节点里，一系列同名的节点描述的都是同一个对象，它们的属性相互叠加，若有冲突，则以最后出现的描述为准，是谓“后来居上”。比方说在<strong>靠前</strong>的地方这样描述这个串口：</p>
<pre><code class="dts">/ {
    soc {
        ...
        serial@40011000 {
            status = &quot;disabled&quot;;
            dma-names = &quot;rx&quot;, &quot;tx&quot;;
            ...
        };
    };
};
</code></pre>
<p>然后在<strong>靠后</strong>的地方又这样描述一遍：</p>
<pre><code class="dts">/ {
    soc {
        // 记得要重新画一次设备树，然后
        // 在相同的枝干下面写同名节点
        serial@40011000 {
            status = &quot;okay&quot;;
        };
    };
};
</code></pre>
<p>最后生成的效果是：</p>
<pre><code class="dts">/ {
    soc {
        ...
        serial@40011000 {
            status = &quot;okay&quot;;
            dma-names = &quot;rx&quot;, &quot;tx&quot;;
            ...
        };
    };
};
</code></pre>
<p>注意到，status属性被改为okay了。</p>
<p>特别要强调的是，如果要在两个文件里面这样干，那么两个文件里面都得画上<strong>结构相同的设备树</strong>，然后在<strong>相同的枝干上写同名的节点</strong>，这才有效。就像上面例子中画了两次设备树，在根节点下soc节点下重写了serial节点。这显然很麻烦。不过可以使用<code>标号</code>和<code>引用</code>来简化。</p>
<p>还有这种操作：拿STM32的设备树作为例子：<br>在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/boot/dts/stm32f429.dtsi#L422" target="_blank" rel="noopener">arch/arm/boot/dts/stm32f429.dtsi</a>里面这样定义串口：</p>
<pre><code class="dts">/ {
    soc {
        ...
        // 跟上面相比，加了标号
        usart1: serial@40011000 {
            status = &quot;disabled&quot;;
            dma-names = &quot;rx&quot;, &quot;tx&quot;;
            ...
        };
    };
};
</code></pre>
<p>然后在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/boot/dts/stm32429i-eval.dts#L286" target="_blank" rel="noopener">arch/arm/boot/dts/stm32f429i-eval.dts</a>里面，include刚才那个设备树，接着使用标号改写这个节点：</p>
<pre><code class="dts">#include &lt;stm32f429.dtsi&gt;
...
// 直接引用那个标号就行了
&amp;usart1 {
    status = &quot;okay&quot;;
};
</code></pre>
<p>最后达到相同的效果。</p>
<h4 id="设备树对应到驱动程序"><a href="#设备树对应到驱动程序" class="headerlink" title="设备树对应到驱动程序"></a>设备树对应到驱动程序</h4><p>设备树会展开为平台设备，但是它并不通过name字段去与平台驱动相匹配，而是通过<code>compatible</code>属性与driver中的<code>compatible</code>相匹配。compatible都是一个字符串。<br>比方说STM32F429的串口在设备树中这样写：</p>
<pre><code class="c">usart1: serial@40011000 {
    compatible = &quot;st,stm32-usart&quot;, 
        &quot;st,stm32-uart&quot;;
    ...
};
</code></pre>
<p>在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/stm32-usart.c#L709" target="_blank" rel="noopener">drivers/tty/serial/stm32-usart.c</a>中这样定义compatible：</p>
<pre><code class="c">static const struct of_device_id stm32_match[] = {
    { .compatible = &quot;st,stm32-usart&quot;, .data = &amp;stm32f4_info},
    { .compatible = &quot;st,stm32-uart&quot;, .data = &amp;stm32f4_info},
    { .compatible = &quot;st,stm32f7-usart&quot;, .data = &amp;stm32f7_info},
    { .compatible = &quot;st,stm32f7-uart&quot;, .data = &amp;stm32f7_info},
    {},
};
...
static struct platform_driver stm32_serial_driver = {
    .driver    = {
        .of_match_table = of_match_ptr(stm32_match),
    },
    ...
};
</code></pre>
<p>设备树和驱动中的compatible字段都可以不只有一个，只要<strong>任何一个字符串相同</strong>，就可以匹配上了。</p>
<p>注意到<code>of_device_id</code>列表里面，每一个compatible项目都对应了一个data成员。驱动匹配上设备后，可以顺藤摸瓜找到相关的data，从而在一个驱动程序里面实现多个相似设备的驱动。</p>
<h4 id="“设备树绑定”，以及“设备树绑定”的文档"><a href="#“设备树绑定”，以及“设备树绑定”的文档" class="headerlink" title="“设备树绑定”，以及“设备树绑定”的文档"></a>“设备树绑定”，以及“设备树绑定”的文档</h4><p>设备树中应该描述哪些属性，属性值应该怎么设置？写BSP的程序员可以自由去定义，然后通过一系列设备树相关接口找到设备树中设置的值。比方说STM32的串口：</p>
<pre><code class="c">usart1: serial@40011000 {
    compatible = &quot;st,stm32-usart&quot;, 
        &quot;st,stm32-uart&quot;;
    reg = &lt;0x40011000 0x400&gt;;
    interrupts = &lt;37&gt;;
    clocks = &lt;&amp;rcc 0 STM32F4_APB2_CLOCK(USART1)&gt;;
    dmas = &lt;&amp;dma2 2 4 0x400 0x0&gt;,
           &lt;&amp;dma2 7 4 0x400 0x0&gt;;
    dma-names = &quot;rx&quot;, &quot;tx&quot;;
    pinctrl-0 = &lt;&amp;usart1_pins_a&gt;;
    pinctrl-names = &quot;default&quot;;
    status = &quot;okay&quot;;
};
</code></pre>
<p>它有各种属性，驱动程序里逐个查找这些属性的配置，比方说：</p>
<ul>
<li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/of/device.c#L24" target="_blank" rel="noopener">of_match_device()</a>通过匹配<code>compatible</code>，找到3.3中所述<code>of_device_id</code>表中对应项，以方便提取其对应的<code>data</code>，作为驱动程序里面自定义的<strong>私有数据</strong>。</li>
<li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/base/platform.c#L67" target="_blank" rel="noopener">platform_get_resource()</a>和<a href="https://elixir.bootlin.com/linux/v4.13.3/source/lib/devres.c#L134" target="_blank" rel="noopener">devm_ioremap_resource()</a>配对使用，提取出设备树节点的<code>reg</code>属性。</li>
<li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/base/platform.c#L87" target="_blank" rel="noopener">platform_get_irq()</a>提取<code>interrupts</code>属性。</li>
<li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/clk/clk-devres.c#L17" target="_blank" rel="noopener">devm_clk_get()</a>提取<code>clocks</code>属性。</li>
<li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/dma/dmaengine.c#L752" target="_blank" rel="noopener">dma_request_slave_channel()</a>输入<code>dma-names</code>里某一个字符串，查找出对应的<code>dmas</code>属性。比方说通过”rx”找到&lt;&amp;dma2 2 4 0x400 0x0&gt;。</li>
</ul>
<p>这些属性可能的配置，以及处理这些配置的代码，<strong>综合起来叫<code>设备树绑定（devicetree bindings）</code></strong>。在源码<code>Documentation/devicetree/bindings/</code>目录下面罗列了一大堆<strong>描述设备树绑定的文档</strong>。</p>
<p>应该说，设备树绑定长什么样，这取决于程序员的设计；有不少属性的用途是“众所周知”的，比方说</p>
<ul>
<li>compatible属性用于匹配驱动</li>
<li>reg属性用于描述改外设接口寄存器的地址空间</li>
<li>pinctrl-0、pinctrl-names用于描述该外设对应到的GPIO</li>
<li><strong>status表示这个外设是否启用</strong></li>
</ul>
<p>有不少属性是该驱动所特有的，比方说，根据<a href="https://elixir.bootlin.com/linux/v4.13.3/source/Documentation/devicetree/bindings/serial/st,stm32-usart.txt" target="_blank" rel="noopener">Documentation/devicetree/bindings/serial/st,stm32-usart.txt</a>文档，还有一个<strong>布尔属性</strong>叫”st,hw-flow-ctrl”，表示是否启用USART的流控功能。</p>
<p><strong>设备树复杂的地方并不在于它的语法，而恰恰在于设备树绑定</strong>。不同的程序员写出的设备树绑定不尽相同，同一个外设在不同芯片中的设备树绑定相差甚远，甚至同名的属性功效完全不同。最典型的例子就是pinctrl了，它管GPIO引脚复用；换一款芯片、换一个BSP，或许也得重新学习一遍它的pinctrl。。。</p>
<p>所以，设备树仿佛变成了最不具有可移植性的那部分了。Linus顺利地将ARM芯片的混乱性，从板级初始化程序中成功转嫁到设备树绑定中去了，然后他仿佛就不管后事了。。。这也为人所诟病：Thomas Petazzoni在2015年的ELC会议上抱怨说：<a href="https://events.static.linuxfound.org/sites/events/files/slides/petazzoni-dt-as-stable-abi-fairy-tale.pdf" target="_blank" rel="noopener">不同内核里设备树绑定要保持可移植性，这简直是个神话</a>。他说，很多厂商推出的系列芯片，它们的数据手册并不存在（doesn’t exist），以至于社区的工程师们要发挥想象力猜测它的功能；不少外设寄存器设计得相当傻逼（stupid），有很多神秘而唐突的使能位叫人捉摸不透，要维护这些驱动简直是折磨。他举出了Marvell和全志的芯片作为反面例子：这些芯片手册又冇，上流社会又要设备树绑定的移植性好；又举出Atmel芯片作为正面例子：Atmel的数据手册流传甚广，但是Atmel的维护者明确地声明：我的设备树绑定不能保证移植性。<a href="https://www.youtube.com/watch?v=rPRqIS9q6CY" target="_blank" rel="noopener">油管视频在此</a>。</p>
<p>不管怎样，时至今日，ARM端的代码已经深刻地与设备树相耦合了。话说回来，设备树也是一个相当优雅的设计，或许这是应对ARM架构芯片纷繁复杂的驱动的最好解决方法了。。。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-04-27T18:59:05.773Z" itemprop="dateUpdated">2019-04-28 02:59:05</time>
</span><br>


        
        欢迎留言，大佬轻拍。。
        
    </div>
    
    <footer>
        <a href="https://hhuysqt.github.io">
            <img src="/img/avatar.jpg" alt="hhuysqt">
            hhuysqt
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ucpc/">ucpc</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://hhuysqt.github.io/ucpc4/&title=《uc-PC[4] 小议“设备树”》 — hhuysqt&pic=https://hhuysqt.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://hhuysqt.github.io/ucpc4/&title=《uc-PC[4] 小议“设备树”》 — hhuysqt&source=讲设备树的文章不少。以下是一些挺有意思的文章：

蜗窝科技的博客紧扣Linux内核来讲设备树的来历与用法；
Thomas Petazzoni是Bootli..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://hhuysqt.github.io/ucpc4/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《uc-PC[4] 小议“设备树”》 — hhuysqt&url=https://hhuysqt.github.io/ucpc4/&via=https://hhuysqt.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://hhuysqt.github.io/ucpc4/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/ucpc5/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">uc-PC[5] Linux设备驱动配置</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/ucpc3/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">uc-PC[3] 板子验证与bootloader移植</h4>
      </a>
    </div>
  
</nav>



    








<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: 'hhuysqt',
            repo: 'hhuysqt.github.io',
            oauth: {
                client_id: 'f3accf3be337dcd6d61d',
                client_secret: 'af75b9e501d76dc85f1f0417d7307419df49aeec',
            },
        })
        gitment.render('comments')
    </script>
</section>













</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>hhuysqt &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://hhuysqt.github.io/ucpc4/&title=《uc-PC[4] 小议“设备树”》 — hhuysqt&pic=https://hhuysqt.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://hhuysqt.github.io/ucpc4/&title=《uc-PC[4] 小议“设备树”》 — hhuysqt&source=讲设备树的文章不少。以下是一些挺有意思的文章：

蜗窝科技的博客紧扣Linux内核来讲设备树的来历与用法；
Thomas Petazzoni是Bootli..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://hhuysqt.github.io/ucpc4/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《uc-PC[4] 小议“设备树”》 — hhuysqt&url=https://hhuysqt.github.io/ucpc4/&via=https://hhuysqt.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://hhuysqt.github.io/ucpc4/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://hhuysqt.github.io/ucpc4/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
