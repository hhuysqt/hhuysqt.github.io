<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>uc-PC[5] Linux设备驱动配置 | hhuysqt</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="ucpc">
    <meta name="description" content="uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，就地运行（XIP，全称execute in place）。 需要使能的功能有：网络、显示、USB、SD卡、摄像头、yaffs。这些功能全部开启的话，内核大小将为4MB以上，而片内flash只有2MB，不模块化的话只能跑在SDRAM上，这回导致性能低下，所以调通设备驱动之后应该进行模块化，将关键部分编译进内核，内核塞进片内fl">
<meta name="keywords" content="ucpc">
<meta property="og:type" content="article">
<meta property="og:title" content="uc-PC[5] Linux设备驱动配置">
<meta property="og:url" content="https://hhuysqt.github.io/ucpc5/index.html">
<meta property="og:site_name" content="hhuysqt">
<meta property="og:description" content="uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，就地运行（XIP，全称execute in place）。 需要使能的功能有：网络、显示、USB、SD卡、摄像头、yaffs。这些功能全部开启的话，内核大小将为4MB以上，而片内flash只有2MB，不模块化的话只能跑在SDRAM上，这回导致性能低下，所以调通设备驱动之后应该进行模块化，将关键部分编译进内核，内核塞进片内fl">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/net-config.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/net-config2.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/net-config2.2.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/net-config3.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/scene3.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/drm.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/drm2.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/drm3.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/drm4.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/fb.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb2.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/scene6.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb3.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb4.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb5.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb6.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb7.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb8.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/usb9.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/mmc.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/dcmi.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/dcmi2.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/dcmi3.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/scene5.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/yaffs.jpeg">
<meta property="og:image" content="https://hhuysqt.github.io/ucpc5/yaffs2.jpeg">
<meta property="og:updated_time" content="2019-04-27T15:20:06.959Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="uc-PC[5] Linux设备驱动配置">
<meta name="twitter:description" content="uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，就地运行（XIP，全称execute in place）。 需要使能的功能有：网络、显示、USB、SD卡、摄像头、yaffs。这些功能全部开启的话，内核大小将为4MB以上，而片内flash只有2MB，不模块化的话只能跑在SDRAM上，这回导致性能低下，所以调通设备驱动之后应该进行模块化，将关键部分编译进内核，内核塞进片内fl">
<meta name="twitter:image" content="https://hhuysqt.github.io/ucpc5/net-config.jpeg">
    
        <link rel="alternate" type="application/atom+xml" title="hhuysqt" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/m.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

  <!-- highlight.js代码高亮主题 css 引入-->
  <link rel="stylesheet" href="/plugins/highlight/styles/github.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<!--
  <script src="/plugins/highlight/highlight.pack.js"></script>
-->
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- highlight.js代码高亮主题 css 引入-->
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">hhuysqt</h5>
          <a href="mailto:1020988872@qq.com" title="1020988872@qq.com" class="mail">1020988872@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                所有文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                索引
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/hhuysqt" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.zhihu.com/people/hhuysqt/activities" target="_blank" >
                <i class="icon icon-lg icon-search-plus"></i>
                知乎
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-male"></i>
                关于我
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">uc-PC[5] Linux设备驱动配置</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">uc-PC[5] Linux设备驱动配置</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-03-07T01:21:49.000Z" itemprop="datePublished" class="page-time">
  2018-03-07
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>目录</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#网络"><span class="post-toc-number">1.</span> <span class="post-toc-text">网络</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#上位机搭建NFS服务器"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">上位机搭建NFS服务器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#一件小事："><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">一件小事：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内核配置"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">内核配置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#源码里的小bug"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">源码里的小bug</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#启动的printk"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">启动的printk</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#nfs作为根文件系统"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">nfs作为根文件系统</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ping"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">ping</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#显示"><span class="post-toc-number">2.</span> <span class="post-toc-text">显示</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用内核中的DRM驱动"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">使用内核中的DRM驱动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#一个小问题"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">一个小问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#仅使用simple-fb"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">仅使用simple-fb</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#USB主机"><span class="post-toc-number">3.</span> <span class="post-toc-text">USB主机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基本配置"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">基本配置</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#添加简单设备：USB串口"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">添加简单设备：USB串口</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#添加U盘驱动"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">添加U盘驱动</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#添加键盘驱动"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">添加键盘驱动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#为啥不能用普通的有线键盘？"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">为啥不能用普通的有线键盘？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SD卡"><span class="post-toc-number">4.</span> <span class="post-toc-text">SD卡</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#方便起见，直接换能用的代码"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">方便起见，直接换能用的代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#挂载SD卡"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">挂载SD卡</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#摄像头"><span class="post-toc-number">5.</span> <span class="post-toc-text">摄像头</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基本配置-1"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">基本配置</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#v4l2应用程序测试"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">v4l2应用程序测试</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#yaffs2"><span class="post-toc-number">6.</span> <span class="post-toc-text">yaffs2</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#打补丁"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">打补丁</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#yaffs作为根文件系统"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">yaffs作为根文件系统</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-ucpc5"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">uc-PC[5] Linux设备驱动配置</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-03-07 09:21:49" datetime="2018-03-07T01:21:49.000Z"  itemprop="datePublished">2018-03-07</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，<strong>就地运行</strong>（XIP，全称execute in place）。</p>
<p>需要使能的功能有：网络、显示、USB、SD卡、摄像头、yaffs。这些功能全部开启的话，内核大小将为4MB以上，而片内flash只有2MB，不模块化的话只能跑在SDRAM上，这回导致性能低下，所以调通设备驱动之后应该进行模块化，将关键部分编译进内核，内核塞进片内flash，从而提高性能。</p>
<p>以下将只描述它们如何配置，而不涉及具体驱动的软件架构。</p>
<ul>
<li>配置之前，应该设置环境变量：<strong>ARCH=arm CROSS_COMPILE=arm-none-eabi-</strong>（其他编译工具链设置也类似），不然的话会按照host的架构去配置。</li>
<li>配置时一般用<code>make menuconfig</code>，如果装了qt的话还可以用<code>make xconfig</code>；后者可以用鼠标操作，全屏的话看到的信息量更多。</li>
<li>搜索某一个配置时，不用加<code>CONFIG_</code>前缀，而且不用管大小写。</li>
<li>某一个配置没有显示出来，是因为它依赖的配置还没有使能；这时就要耐着性子去一个个翻找。。。</li>
</ul>
<p><em>（手机请横屏看代码）</em><br><a id="more"></a></p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>Linux内核实现了相当完整而庞大的网络协议栈——对于单片机来说实在过于庞大；并且，协议栈部分是必须编译进内核而不能模块化的，因此这一块只能放置于片内flash中；而且，只在defconfig的基础上使能网络的话，内核就超过了2MB了。因此在调通板子上的驱动之前，内核都只能在SDRAM上面就地运行。。参考前文bootloader的配置。</p>
<p>下面实现基本的网络功能：获取IP、跑通nfs。诸如DNS之类的暂时不弄。</p>
<h4 id="上位机搭建NFS服务器"><a href="#上位机搭建NFS服务器" class="headerlink" title="上位机搭建NFS服务器"></a>上位机搭建NFS服务器</h4><pre><code class="bash">$ sudo apt install nfs-common
</code></pre>
<p>我的nfs目录是<code>/home/hyq/nfs</code>，为此修改配置文件<code>/etc/exports</code>：</p>
<pre><code>/home/hyq/nfs *(rw,sync,no_root_squash,no_subtree_check)
</code></pre><p>重启服务以生效：</p>
<pre><code class="bash">$ sudo /etc/init.d/nfs-kernel-server restart
</code></pre>
<h5 id="一件小事："><a href="#一件小事：" class="headerlink" title="一件小事："></a>一件小事：</h5><p>有时候调板子是这种情况：电脑要连校园网WiFi来科学上网（因为有ipv6），板子连着一个不上网的路由器，电脑又需要通过网线来连那个路由器来访问板子。这时候电脑如果不插网线就能上网，插了就上不了网了。这是因为默认的路由指向了以太网。需要通过<code>route</code>命令来将路由改到WiFi上。首先查看路由表：</p>
<pre><code>$ route
内核 IP 路由表
目标       网关         子网掩码   标志 跃点  引用 使用 接口
default   OpenWrt.lan  0.0.0.0   UG  100   0    0   enp2s0
...
</code></pre><p>我电脑的以太网接口是enp2s0，WiFi接口是wlp1s0（别的电脑可能分别是eth0和wlan0）。default到了enp2s0，将其路由到wlp1s0：</p>
<pre><code>$ sudo route del default
$ sudo route add default gw &lt;只连WiFi时候的网关&gt; wlp1s0
</code></pre><p>此时默认就路由到WiFi上了。此时或许还可能上不了网但是能ping外网。此时就要在<code>/etc/resolv.conf</code>里面改DNS，比方说改为114.114.114.114，然后就可以上网了。</p>
<h4 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h4><p>在第一层次的配置中使能<code>Networking support</code>，然后在其下<code>Networking options</code>下面使能<code>TCP/IP networking</code>，我只留了这些配置：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/net-config.jpeg" alt="最小网络配置" title="">
                </div>
                <div class="image-caption">最小网络配置</div>
            </figure></p>
<p>并且添加网卡驱动：分别需要MAC和phy的驱动。在<code>Device Drivers</code>-&gt;<code>Network device support</code>-&gt;<code>Ethernet driver support</code>下面选择STM32的MAC。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/net-config2.jpeg" alt="MAC配置" title="">
                </div>
                <div class="image-caption">MAC配置</div>
            </figure></p>
<p>phy的驱动可以选择默认的<code>CONFIG_FIXED_PHY</code>，也可以选择SMSC的phy，都可以成功驱动LAN8720A。在<code>Device Drivers</code>-&gt;<code>Network device support</code>-&gt;<code>PHY Device support and infrastructure</code>下选择。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/net-config2.2.jpeg" alt="网卡配置" title="">
                </div>
                <div class="image-caption">网卡配置</div>
            </figure></p>
<p>然后修改设备树：<br>首先在<code>stm32f429.dtsi</code>里的pinctrl节点下增加一个RMII引脚的配置，并且在ethernet节点下面添加mac地址；mac地址可以随便设置，只要不跟局域网里面的设备重合就行了：</p>
<pre><code class="c">/ {
    ...
    soc {
        ...
        pinctrl: pin-controller {
            ...

            // RMII引脚复用的配置
            ethernet_rmii: rmii@0 {
                pins {
                    pinmux = &lt;STM32F429_PB12_FUNC_ETH_MII_TXD0_ETH_RMII_TXD0&gt;,
                        &lt;STM32F429_PB13_FUNC_ETH_MII_TXD1_ETH_RMII_TXD1&gt;,
                        &lt;STM32F429_PB11_FUNC_ETH_MII_TX_EN_ETH_RMII_TX_EN&gt;,
                        ...
                    slew-rate = &lt;3&gt;;
                };
            };
            ...
        };
        ...

        // ethernet节点
        mac: ethernet@40028000 {
            // 添加mac地址
            mac-address = [C0 B1 3D 88 88 89];
            // 其他属性照旧
        };
    };
};
</code></pre>
<p>然后在<code>stm32f429-disco.dts</code>里补充设置ethernet节点：</p>
<pre><code class="c">&amp;mac {
    status = &quot;okay&quot;;
    pinctrl-0   = &lt;&amp;ethernet_rmii&gt;;
    pinctrl-names = &quot;default&quot;;
    phy-mode    = &quot;rmii&quot;;
    snps,reset-gpio = &lt;&amp;gpioh 2 GPIO_ACTIVE_HIGH&gt;;
    snps,reset-active-low;
    snps,reset-delays-us = &lt;0 10000 100000&gt;;
};
</code></pre>
<p>这些设置的来源是<a href="https://elixir.bootlin.com/linux/latest/source/Documentation/devicetree/bindings/net/stm32-dwmac.txt" target="_blank" rel="noopener">Documentation/devicetree/bindings/net/stm32-dwmac.txt</a>。这里并不需要像stm32429i-eval评估板设置的那么繁琐，只需要设置哪一套引脚、RMII模式，以及phy芯片的reset引脚即可。</p>
<h5 id="源码里的小bug"><a href="#源码里的小bug" class="headerlink" title="源码里的小bug"></a>源码里的小bug</h5><p>stm32的MAC初始化是<code>drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c</code>的<code>stm32_dwmac_init()</code>，它根据配置将外设设置为MII模式或RMII模式。<a href="https://elixir.bootlin.com/linux/latest/source/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c#L42" target="_blank" rel="noopener">原代码第42行左右</a>RMII模式寄存器设置错误。本网卡只有RMII模式，而stm32429i-eval的网卡工作在MII模式，估计因此他们没查出这个bug。</p>
<pre><code class="c">-  val = (plat_dat-&gt;interface == PHY_INTERFACE_MODE_MII) ? 0 : 1;
+  val = (plat_dat-&gt;interface == PHY_INTERFACE_MODE_MII) ? 0 : MII_PHY_SEL_MASK;
</code></pre>
<h5 id="启动的printk"><a href="#启动的printk" class="headerlink" title="启动的printk"></a>启动的printk</h5><pre><code>[    3.430000] libphy: Fixed MDIO Bus: probed
[    3.470000] stm32-dwmac 40028000.ethernet: PTP uses main clock
[    3.480000] stm32-dwmac 40028000.ethernet: no reset control found
[    3.480000] stmmac - user ID: 0x10, Synopsys ID: 0x35
[    3.490000] stm32-dwmac 40028000.ethernet: Ring mode enabled
[    3.500000] stm32-dwmac 40028000.ethernet: DMA HW capability register supported
[    3.510000] stm32-dwmac 40028000.ethernet: Enhanced/Alternate descriptors
[    3.510000] stm32-dwmac 40028000.ethernet: Enabled extended descriptors
[    3.520000] stm32-dwmac 40028000.ethernet: RX Checksum Offload Engine supported
[    3.530000] stm32-dwmac 40028000.ethernet: COE Type 2
[    3.530000] stm32-dwmac 40028000.ethernet: TX Checksum insertion supported
[    3.540000] stm32-dwmac 40028000.ethernet: Wake-Up On Lan supported
[    3.550000] stm32-dwmac 40028000.ethernet: Enable RX Mitigation via HW Watchdog Timer
[    4.200000] libphy: stmmac: probed
...
[    4.330000] stm32_rtc 40002800.rtc: setting system clock to 2000-01-01 03:07:42 UTC (946696062)
[    4.540000] SMSC LAN8710/LAN8720 stmmac-0:00: attached PHY driver [SMSC LAN8710/LAN8720] (mii_bus:phy_addr=stmmac-0:00, irq=-1)
[    4.600000] stmmac_init_dma_engine, reset addr: 40028000
[    4.600000] stm32-dwmac 40028000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported
[    6.930000] stm32-dwmac 40028000.ethernet eth0: Link is Up - 100Mbps/Full - flow control rx/tx
</code></pre><h4 id="nfs作为根文件系统"><a href="#nfs作为根文件系统" class="headerlink" title="nfs作为根文件系统"></a>nfs作为根文件系统</h4><p>首先电脑的nfs目录下面得有完整的rootfs；可以暂时先从网上<a href="https://elinux.org/File:Stm32_mini_rootfs.cpio.bz2" target="_blank" rel="noopener">下载一个可用的rootfs</a>，然后解压到那里。</p>
<p>然后配置内核以使能NFS；<strong>并且需要配置<code>ROOT_NFS</code></strong>：在<code>File systems</code>-&gt;<code>Network File Systems</code>下面即可配置。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/net-config3.jpeg" alt="nfs配置" title="">
                </div>
                <div class="image-caption">nfs配置</div>
            </figure></p>
<p>最后在<a href="https://elixir.bootlin.com/linux/latest/source/arch/arm/boot/dts/stm32f429-disco.dts" target="_blank" rel="noopener">stm32f429-disco.dts</a>里面添加内核参数。现在的风格是，kernel command line加在设备树的chosen节点下面，而不是uboot传tags。</p>
<pre><code>/ {
    chosen {
        bootargs = &quot;root=/dev/nfs rw &quot;
          &quot;ip=192.168.2.123:192.168.2.1:::stm32:eth0:on &quot;
          &quot;nfsroot=192.168.2.202:/home/hyq/nfs&quot;;
    };
    ...
};

</code></pre><p>其中，<code>ip</code>可以设置为<code>ip=dhcp</code>，也可以像上述那样设置一个固定的地址；<code>nfsroot</code>对应到上位机的ip地址和nfs目录。</p>
<h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>因为没有DNS，所以不能ping百度之类的域名，只能ping IP地址。而且，如果内核参数是<code>ip=dhcp</code>的话，可以ping通外网；如果只是一个固定地址就只能ping局域网里面的东西。。下面ping的是114.114.114.114这个DNS服务器：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/scene3.jpeg" alt="ping外网IP地址" title="">
                </div>
                <div class="image-caption">ping外网IP地址</div>
            </figure></p>
<h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>主流内核中STM32的LTDC驱动居然放在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/gpu/drm/stm/" target="_blank" rel="noopener">drivers/gpu/drm/stm/</a>目录下面。。。想必ST认为它的DMA2D可以算是一个gpu了，于是就要用内核里面的DRM架构了。。实在志不在小。。而emcraft的uclinux中stm32显示驱动还仅仅放在<a href="https://github.com/robutest/uclinux/blob/master/drivers/video/stm32fb.c" target="_blank" rel="noopener">drivers/video/</a>目录下面。</p>
<p>对于单片机来说，使用DRM架构的一大缺点是它实在太庞大了，塞不进片内flash，只能模块化以跑在SDRAM里，因而性能低下；因此应该选用尽量简单的驱动以避免这一点。</p>
<h4 id="使用内核中的DRM驱动"><a href="#使用内核中的DRM驱动" class="headerlink" title="使用内核中的DRM驱动"></a>使用内核中的DRM驱动</h4><p>内核配置：开启DRM：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/drm.jpeg" alt="DRM" title="">
                </div>
                <div class="image-caption">DRM</div>
            </figure></p>
<p>还要开启STM32的DRM支持：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/drm2.jpeg" alt="STM32 DRM" title="">
                </div>
                <div class="image-caption">STM32 DRM</div>
            </figure></p>
<p>还要开启一个panel。这里为简单起见，选择simple-panel<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/drm3.jpeg" alt="panel" title="">
                </div>
                <div class="image-caption">panel</div>
            </figure></p>
<p>DRM架构需要有一个panel，即外接的那个液晶屏控制器。有些RGB的lcd也要用诸如I2C接口去配置一些奇怪的参数。板子上直接将RGB用DAC转化成VGA信号了，所以选择一个“哑”的panel，即CONFIG_PANEL_SIMPLE。在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/gpu/drm/panel/panel-simple.c" target="_blank" rel="noopener">drivers/gpu/drm/panel/panel-simple.c</a>里面实现了一大堆LCD，它们只需要开关背光灯就行了。于是在里面找一个想要的尺寸——比如标准VGA信号的640x480——的屏幕，这里选择了et057090dhu，然后稍微改一下那些时钟配置，适合60HZ的VGA：</p>
<pre><code class="c">static const struct drm_display_mode edt_et057090dhu_mode = {
    .clock = 31468,
    .hdisplay =    640,
    .hsync_start = 640 + 16,
    .hsync_end =   640 + 16 + 96,
    .htotal =      640 + 16 + 96 + 48,
    .vdisplay =    480,
    .vsync_start = 480 + 10,
    .vsync_end =   480 + 10 + 2,
    .vtotal =      480 + 10 + 2 + 33,
    .vrefresh = 60,
    .flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
};
</code></pre>
<p>设备树需要增加panel-rgb节点，并且有两个endpoint相互指引。改写如下：</p>
<pre><code class="c">/{
    panel_rgb: panel-rgb {
        compatible = &quot;edt,et057090dhu&quot;;
        status = &quot;okay&quot;;
        port {
            panel_in_rgb: endpoint {
                // 链接到下面的ltdc_out_rgb节点
                remote-endpoint = &lt;&amp;ltdc_out_rgb&gt;;
            };
        };
    };
    ...
};
&amp;ltdc {
    status = &quot;okay&quot;;
    pinctrl-0 = &lt;&amp;ltdc_pins&gt;;
    pinctrl-names = &quot;default&quot;;
    dma-ranges;
    port {
        ltdc_out_rgb: endpoint {
            // 链接到上面的panel_in_rgb节点
            remote-endpoint = &lt;&amp;panel_in_rgb&gt;;
        };
    };
};
</code></pre>
<p>为了启用tty终端，还需要选择<code>CONFIG_FRAMEBUFFER_CONSOLE</code>：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/drm4.jpeg" alt="fbterm" title="">
                </div>
                <div class="image-caption">fbterm</div>
            </figure></p>
<p>接上显示器，启动之后，就可以看到它在屏幕上慢悠悠地printk()了。。</p>
<h5 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h5><p>内核初始化结束后，会统一将未用到的外设的时钟关掉；但是这个ltdc的驱动并没有向内核注册时钟，于是它最后就被关掉了。。。于是在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/clk/clk-stm32f4.c#L143" target="_blank" rel="noopener">drivers/clk/clk-stm32f4.c</a>里为ltdc时钟添加<code>CLK_IGNORE_UNUSED</code>的属性。</p>
<pre><code class="c">static const struct stm32f4_gate_data 
    stm32f429_gates[] __initconst = {
    ...
    { STM32F4_RCC_APB2ENR, 26, &quot;ltdc&quot;, &quot;apb2_div&quot;,
      CLK_IGNORE_UNUSED },
};
</code></pre>
<h4 id="仅使用simple-fb"><a href="#仅使用simple-fb" class="headerlink" title="仅使用simple-fb"></a>仅使用simple-fb</h4><p>这是最简单的方法：bootloader里面初始化显示器，然后给内核传参framebuffer的地址，从而不用那个庞大的DRM架构。初始化部分在bootloader里已讲述。</p>
<p>在<code>Device Drivers</code>-&gt;<code>Graphics support</code>-&gt;<code>Frame buffer Devices</code>下找到<code>Simple framebuffer support</code>：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/fb.jpeg" alt="simple-fb" title="">
                </div>
                <div class="image-caption">simple-fb</div>
            </figure></p>
<p>在设备树的chosen节点下增加一个framebuffer节点：</p>
<pre><code class="c">/ {
    chosen {
        framebuffer0: framebuffer@83f00000 {
            compatible = &quot;simple-framebuffer&quot;;
            reg = &lt;0x83f00000 (640 * 480 * 2)&gt;;
            width = &lt;640&gt;;
            height = &lt;480&gt;;
            stride = &lt;(640 * 2)&gt;;
            format = &quot;r5g6b5&quot;;
            clocks = &lt;&amp;rcc 1 CLK_LCD&gt;;
        };
    };
};
</code></pre>
<p>其中reg属性是framebuffer的地址，其余属性顾名思义。</p>
<p>显示驱动就可以塞进内核从而跑在片内flash里了。启动之后明显感到刷屏速度增加了数倍。</p>
<h3 id="USB主机"><a href="#USB主机" class="headerlink" title="USB主机"></a>USB主机</h3><p>STM32F429有两个USB 2.0，一个是全速USB，一个是全速、高速USB，二者片内集成了全速的phy，而后者需要外接phy芯片才能实现高速USB。为简单起见，uc-PC只引出了两个全速USB。虽然它们的寄存器组都非常相似，而且它们都使用Linux内核中相同的驱动，但是它们的表现不太一样。高速USB工作在全速USB下会有点不爽。</p>
<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>跟很多SOC一样，stm32的很多外设都是Designware的IP，所以驱动比较通用；在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/dwc2/params.c#L149" target="_blank" rel="noopener">drivers/usb/dwc2</a>里面见到stm32的USB驱动竟诸如树莓派（BCM2835）之类的USB驱动并列时，不必惊讶。内核配置在<code>Device Drivers</code>-&gt;<code>USB support</code>下面找到<code>DesignWare USB2 DRD Core Support</code>：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb.jpeg" alt="stm32 dw usb" title="">
                </div>
                <div class="image-caption">stm32 dw usb</div>
            </figure></p>
<p>设备树里面添加两个USB节点：</p>
<pre><code class="c">&amp;usbotg_hs {
    compatible = &quot;st,stm32f4x9-fsotg&quot;;
    dr_mode = &quot;host&quot;;
    pinctrl-0 = &lt;&amp;usbotg_fs_pins_b&gt;;
    pinctrl-names = &quot;default&quot;;
    status = &quot;okay&quot;;
};

&amp;usbotg_fs {
    compatible = &quot;st,stm32f4x9-fsotg&quot;;
    dr_mode = &quot;host&quot;;
    pinctrl-0 = &lt;&amp;usbotg_fs_pins_a&gt;;
    pinctrl-names = &quot;default&quot;;
    status = &quot;okay&quot;;
};
</code></pre>
<p>但是按照默认代码，高速USB启动时候有错：</p>
<pre><code>[4.320000] dwc2 40040000.usb: dwc2_core_reset() HANG! Soft Reset GRSTCTL=80000001
</code></pre><p>这是因为，dwc的USB HS在配置之前需要复位：通过置位GRSTCTL的第0位，然后等待硬件清零。stm32的USB HS默认是外接PHY芯片的高速模式，软件复位时候需要等PHY芯片。但是板子只有内置PHY。选择内置PHY需要置位GUSBCFG的第6位。</p>
<p><a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/dwc2/platform.c#L418" target="_blank" rel="noopener">drivers/usb/dwc2/platform.c:dwc2_driver_probe()</a>函数中，首先软件复位，然后在后面的<a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/dwc2/hcd.c#L136" target="_blank" rel="noopener">drivers/usb/dwc2/hcd.c:dwc2_fs_phy_init()</a>才设置为内置PHY。前面的软件复位等的是外部PHY，于是卡死，无论后面再怎么设置内置PHY。因此需要在前面先将其设置为全速USB模式：</p>
<pre><code class="c">    // 第418行前面，先设置为全速USB模式
    // 其实严格来说应该用writel接口的。。。
    *(uint32_t*)0x4004000c |= 0x00000040;
    msleep(1);
    dwc2_core_reset_and_force_dr_mode(hsotg);
</code></pre>
<p>然后就能启动了。虽然下面的printk还是有点问题，但是启动之后这个USB是没问题的，姑且就不管它了。</p>
<pre><code>[4.950000] dwc2 40040000.usb: dwc2_wait_for_mode: Couldn&#39;t set host mode
[4.960000] dwc2 40040000.usb: DWC OTG Controller
[4.960000] dwc2 40040000.usb: new USB bus registered, assigned bus number 1
[4.970000] dwc2 40040000.usb: irq 50, io mem 0x40040000
[5.010000] hub 1-0:1.0: USB hub found
[5.020000] hub 1-0:1.0: 1 port detected
</code></pre><h4 id="添加简单设备：USB串口"><a href="#添加简单设备：USB串口" class="headerlink" title="添加简单设备：USB串口"></a>添加简单设备：USB串口</h4><p>直接添加驱动就可以了，比方说PL2303驱动：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb2.jpeg" alt="pl2303驱动配置" title="">
                </div>
                <div class="image-caption">pl2303驱动配置</div>
            </figure></p>
<p>启动后插上PL2303串口，就可以有<strong>/dev/ttyUSB0</strong>了：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/scene6.jpeg" alt="pl2303插入板子" title="">
                </div>
                <div class="image-caption">pl2303插入板子</div>
            </figure></p>
<p>（其实USB hub是相当通用的233）</p>
<h4 id="添加U盘驱动"><a href="#添加U盘驱动" class="headerlink" title="添加U盘驱动"></a>添加U盘驱动</h4><p>需要先在<code>Device Drivers</code>-&gt;<code>SCSI device support</code>里面使能SCSI以及SCSI disk：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb3.jpeg" alt="SCSI" title="">
                </div>
                <div class="image-caption">SCSI</div>
            </figure></p>
<p>然后在<code>Device Drivers</code>-&gt;<code>USB support</code>下面使能USB Mass Storage：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb4.jpeg" alt="USB storage" title="">
                </div>
                <div class="image-caption">USB storage</div>
            </figure></p>
<p>还要有一个文件系统：比方说fatfs，在<code>File systems</code>-&gt;<code>DOS/FAT/NT Filesystems</code>下面：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb5.jpeg" alt="VFAT" title="">
                </div>
                <div class="image-caption">VFAT</div>
            </figure></p>
<p>而且还需要有一个字符编码，即所谓的”Native language support”，不然U盘会挂载失败。这里选用”NLS ISO 8859-1”：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb6.jpeg" alt="nls" title="">
                </div>
                <div class="image-caption">nls</div>
            </figure></p>
<p>插入U盘后就可以有以下printk：</p>
<pre><code>[ 49.210000] usb 2-1: new full-speed USB device number 2 using dwc2
[ 49.460000] usb 2-1: not running at top speed; connect to a high speed hub
[ 49.480000] usb 2-1: New USB device found, idVendor=14cd, idProduct=1212
[ 49.490000] usb 2-1: New USB device strings: Mfr=1, Product=3, SerialNumber=2
[ 49.500000] usb 2-1: Product: Mass Storage Device
[ 49.510000] usb 2-1: Manufacturer: Generic
[ 49.520000] usb 2-1: SerialNumber: 121220130416
[112.900000] SCSI subsystem initialized
[112.990000] usb-storage 2-1:1.0: USB Mass Storage device detected
[113.010000] scsi host0: usb-storage 2-1:1.0
[113.020000] usbcore: registered new interface driver usb-storage
[114.080000] scsi 0:0:0:0: Direct-Access     Mass     Storage Device   1.00 PQ: 0 ANSI: 0 CCS
[120.110000] sd 0:0:0:0: [sda] 15523840 512-byte logical blocks: (7.95 GB/7.40 GiB)
[120.130000] sd 0:0:0:0: [sda] Write Protect is off
[120.140000] sd 0:0:0:0: [sda] Mode Sense: 03 00 00 00
[120.160000] sd 0:0:0:0: [sda] No Caching mode page found
[120.170000] sd 0:0:0:0: [sda] Assuming drive cache: write through
[120.200000] random: crng init done
[120.210000]  sda: sda1 sda2
[120.230000] sd 0:0:0:0: [sda] Attached SCSI removable disk
</code></pre><p>可见它已经识别到/dev/sda1、/dev/sda2了。这个U盘里是树莓派的rootfs，其中第一个分区是fat格式，可以挂载来看看：</p>
<pre><code>/ # mount -t vfat /dev/sda1 /mnt/
[  233.320000] FAT-fs (sda1): Volume was not properly unmounted. Some data may be corrupt. Please run fsck.
/ # ls mnt
bcm2709-rpi-2-b.dtb  fixup.dat            start.elf
bcm2710-rpi-3-b.dtb  fixup_cd.dat         start_cd.elf
bootcode.bin         fixup_db.dat         start_db.elf
capture              fixup_x.dat          start_x.elf
cmdline.txt          kernel7.img
config.txt           overlays
/ # 
</code></pre><h4 id="添加键盘驱动"><a href="#添加键盘驱动" class="headerlink" title="添加键盘驱动"></a>添加键盘驱动</h4><p>键盘驱动也相当通用，直接配置它即可。在<code>Device Drivers</code>-&gt;<code>HID support</code>里面选择<code>Generic HID driver</code>，并且在<code>USB HID drivers</code>下面还要选<code>USB HID transport layer</code>：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb7.jpeg" alt="usb键盘" title="">
                </div>
                <div class="image-caption">usb键盘</div>
            </figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb8.jpeg" alt="usb键盘" title="">
                </div>
                <div class="image-caption">usb键盘</div>
            </figure>
<p>然后插上一个<strong>无线键盘</strong>（一定要无线键盘或者机械键盘，普通的有线键盘不行。。），就可以有下面的printk：</p>
<pre><code>[  830.670000] usb 2-1: new full-speed USB device number 3 using dwc2
[  830.930000] usb 2-1: New USB device found, idVendor=24ae, idProduct=2010
[  830.940000] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=0
[  830.950000] usb 2-1: Product: Rapoo 2.4G Wireless Device
[  830.960000] usb 2-1: Manufacturer: RAPOO
[  831.000000] input: RAPOO Rapoo 2.4G Wireless Device as /devices/platform/soc/50000000.usb/usb2/2-1/2-1:1.0/0003:24AE:2010.0001/input/input0
[  831.010000] hid-generic 0003:24AE:2010.0001: input,hidraw0: USB HID v1.10 Mouse [RAPOO Rapoo 2.4G Wireless Device] on usb-50000000.usb-1/input0
[  831.080000] input: RAPOO Rapoo 2.4G Wireless Device as /devices/platform/soc/50000000.usb/usb2/2-1/2-1:1.1/0003:24AE:2010.0002/input/input1
[  831.160000] hid-generic 0003:24AE:2010.0002: input,hiddev96,hidraw1: USB HID v1.10 Device [RAPOO Rapoo 2.4G Wireless Device] on usb-50000000.usb-1/input1
[  831.210000] input: RAPOO Rapoo 2.4G Wireless Device as /devices/platform/soc/50000000.usb/usb2/2-1/2-1:1.2/0003:24AE:2010.0003/input/input2
[  831.290000] hid-generic 0003:24AE:2010.0003: input,hidraw2: USB HID v1.10 Keyboard [RAPOO Rapoo 2.4G Wireless Device] on usb-50000000.usb-1/input2
</code></pre><p>此时敲击键盘，屏幕上的终端将会有显示：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/usb9.jpeg" alt="键盘orz" title="">
                </div>
                <div class="image-caption">键盘orz</div>
            </figure></p>
<p>其实Linux的input事件是全局性的，因此只要驱动配好了，就有反应了。</p>
<h5 id="为啥不能用普通的有线键盘？"><a href="#为啥不能用普通的有线键盘？" class="headerlink" title="为啥不能用普通的有线键盘？"></a>为啥不能用普通的有线键盘？</h5><p>stm32的USB在Linux下的驱动有个很大的问题：它不识别低速设备。。。整天枚举失败。。。这估计是stm32跑Linux的性能太低了，以至于设备跑得比stm32都要快，于是就说设备不接受地址云云。。而低端的有线键盘都是低速设备，于是枚举失败。。</p>
<pre><code>[ 1506.090000] usb 2-1: new low-speed USB device number 6 using dwc2
[ 1506.310000] usb 2-1: device descriptor read/64, error -71
</code></pre><h3 id="SD卡"><a href="#SD卡" class="headerlink" title="SD卡"></a>SD卡</h3><p>emcraft的4.2内核中，SD卡驱动直接用arm通用的驱动”arm,primecell”，这个compatible在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/of/platform.c#L376" target="_blank" rel="noopener">drivers/of/platform.c</a>里面匹配，并生成一个amba总线。另外它在drivers/mmc/host/mmci.c里面实现了一个variant_stm32f4，从而接入Linux的mmc驱动栈中。</p>
<p>按理说主流的Linux 4.13内核也是可以这么干的，但是这里的drivers/mmc/host/mmci.c的数据结构跟前者并不完全相同，而且逻辑处理也不同了。这导致SD卡整天不能识别。。</p>
<h4 id="方便起见，直接换能用的代码"><a href="#方便起见，直接换能用的代码" class="headerlink" title="方便起见，直接换能用的代码"></a>方便起见，直接换能用的代码</h4><p>将emcraft的mmci.c、mmci.h复制过来直接用。。。<br>内核配置：选择<code>ARM AMBA Multimedia Card Interface support</code>以及<code>MMC block device driver</code>：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/mmc.jpeg" alt="mmc配置" title="">
                </div>
                <div class="image-caption">mmc配置</div>
            </figure></p>
<p>设备树增加mmc节点，基本照抄emcraft的，不过并没用DMA，因为性能比较低下，DMA很容易下溢死掉：</p>
<pre><code class="c">sdio:sdi@40012C00 {
    compatible = &quot;arm,primecell&quot;;
    reg = &lt;0x40012C00 0x400&gt;;
    interrupts = &lt;49&gt;;
    max-frequency = &lt;25000000&gt;;
    bus-width = &lt;4&gt;;
    voltage-ranges = &lt;3200 3300 3300 3400&gt;;
    clocks = &lt;&amp;rcc 0 171&gt;;
    clock-names = &quot;apb_pclk&quot;;
    arm,primecell-periphid = &lt;0x40480180&gt;;
    status = &quot;disabled&quot;;
};

...
&amp;sdio {
    status = &quot;okay&quot;;
    pinctrl-names = &quot;default&quot;;
    pinctrl-0 = &lt;&amp;sdio_pins&gt;;
    cd-gpio = &lt;&amp;gpioh 15 GPIO_ACTIVE_LOW&gt;;
};
</code></pre>
<p>其中<code>cd-gpio</code>是卡识别的GPIO。</p>
<h4 id="挂载SD卡"><a href="#挂载SD卡" class="headerlink" title="挂载SD卡"></a>挂载SD卡</h4><p>插卡后，将有以下的printk：</p>
<pre><code>[ 5492.300000] mmc0: host does not support reading read-only switch, assuming write-enable
[ 5492.310000] mmc0: new SD card at address 0001
[ 5492.320000] mmcblk0: mmc0:0001  971 MiB 
[ 5492.340000]  mmcblk0: p1 p2
/ # ls /dev/mmcblk0*
/dev/mmcblk0    /dev/mmcblk0p1  /dev/mmcblk0p2
/ # 
</code></pre><p>此时就可以正常挂载它了。不过有时候会出现EIO错误；发出EIO的地方是<a href="https://elixir.bootlin.com/linux/latest/source/drivers/mmc/host/mmci.c#L961" target="_blank" rel="noopener">mmci.c：mmci_data_irq</a>第995行左右的 if (status &amp; MCI_RXOVERRUN)，这是<strong>SDIO的FIFO溢出了</strong>，说明主控取数据太慢了。。解决的办法是<strong>开硬件流控制</strong>，当sdio发现fifo溢出时候会卡一下时钟，免得sd卡跑的太快。这就需要在variant_stm32f4里面加一个控制位：</p>
<pre><code>.clkreg_enable          = MCI_ST_UX500_HWFCEN,
</code></pre><p>这是SDIO_CLKCR的第14位。</p>
<p>有时候也会有EILSEQ错误，也是在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/mmc/host/mmci.c#L949" target="_blank" rel="noopener">mmci.c：mmci_data_irq</a>里面发出的，<strong>起因是CRC错误</strong>，这可能是因为走线不太好或者接触不良啥的。于是<strong>降低时钟频率</strong>：调高SDIO_CLKCR的低8位分频数，于是variant_stm32f4的clkreg_enable变成：</p>
<pre><code>.clkreg_enable          = MCI_ST_UX500_HWFCEN | 0x00000006,
</code></pre><p>然后就没错了。。。</p>
<h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><p>Linux里面集成了STM32的DCMI驱动，直接用就行了。</p>
<h4 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h4><p>在<code>Device Drivers</code>-&gt;<code>Multimedia support</code>-&gt;<code>V4L platform devices</code>里面使能DCMI的驱动：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/dcmi.jpeg" alt="STM32 DCMI" title="">
                </div>
                <div class="image-caption">STM32 DCMI</div>
            </figure></p>
<p>然后添加摄像头驱动。记得要<strong>先取消掉<code>Autoselect ancillary drivers</code>的选项</strong>，下面才有一系列的摄像头驱动可选：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/dcmi2.jpeg" alt="摄像头驱动" title="">
                </div>
                <div class="image-caption">摄像头驱动</div>
            </figure></p>
<p>不妨添加OV2640的驱动。这是一个200万像素的摄像头，可以输出RGB、YUV、JPEG格式的照片。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/dcmi3.jpeg" alt="OV2640驱动" title="">
                </div>
                <div class="image-caption">OV2640驱动</div>
            </figure></p>
<p>然后设备树中，<strong>在I2C节点下面</strong>添加OV2640的节点：</p>
<pre><code class="c">&amp;i2c1 {
    status = &quot;okay&quot;;

    ov2640: camera@30 {
        compatible = &quot;ovti,ov2640&quot;;
        reg = &lt;0x30&gt;;
        clocks = &lt;&amp;clk_ext_camera&gt;;
        clock-names = &quot;xvclk&quot;;
        status = &quot;okay&quot;;
        port {
            // 指向下面的dcmi_0 endpoint
            ov2640_0: endpoint {
                remote-endpoint = &lt;&amp;dcmi_0&gt;;
            };
        };
    };
};

&amp;dcmi {
    status = &quot;okay&quot;;

    port {
        dcmi_0: endpoint {
            // 指向上面的ov2640 endpoint
            remote-endpoint = &lt;&amp;ov2640_0&gt;;
            bus-width = &lt;8&gt;;
            hsync-active = &lt;0&gt;;
            vsync-active = &lt;0&gt;;
            pclk-sample = &lt;1&gt;;
        };
    };
};
</code></pre>
<p>配置基本上照抄stm32429i-eval的配置。</p>
<p>启动之后可以看到摄像头的printk：</p>
<pre><code>[    5.600000] stm32f4-i2c 40005400.i2c: STM32F4 I2C driver registered
[    5.760000] Linux video capture interface: v2.00
[    5.870000] stm32-dcmi 50050000.dcmi: Probe done
[    5.970000] ov2640 0-0030: ov2640 Product ID 26:42 Manufacturer ID 7f:a2
[    5.990000] i2c i2c-0: OV2640 Probed
</code></pre><h4 id="v4l2应用程序测试"><a href="#v4l2应用程序测试" class="headerlink" title="v4l2应用程序测试"></a>v4l2应用程序测试</h4><p>v4l2有个官方测试程序<a href="https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/capture.c.html" target="_blank" rel="noopener">capture.c</a>，它将摄像头数据写入文件中。可以改写一下，将裸RGB数据写到/dev/fb0中，那么就可以在显示器上看到摄像头的数据了。比方说这样写：</p>
<pre><code class="c">// 先打开/dev/fb0
fp = fopen(&quot;/dev/fb0&quot;, &quot;w&quot;);
framebuffer = malloc(640*480*2);

// 在主循环里面将数据写入framebuffer
static void process_image(const void *p, int size)
{
    short *fb = framebuffer, *src = p;
    if (out_buf) {
        for(int y = 0; y &lt; 240; y++)
            for(int x = 0; x &lt; 320; x++)
                fb[y*2*640 + x*2] = src[y*320 + x];
        fseek(fp, 0, SEEK_SET);
        fwrite(fb, 640*480*2, 1, fp);
    }

    fflush(stderr);
    fprintf(stderr, &quot;.&quot;);
    fflush(stdout);
}
</code></pre>
<p>编译之后，使用<code>.capture -o -f -c 10</code>，即是获取10张照片并写入framebuffer。可以在显示器上看到照片：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/scene5.jpeg" alt="摄像头测试" title="">
                </div>
                <div class="image-caption">摄像头测试</div>
            </figure></p>
<p>不过由于STM32的DMA最多只能搬运64k个单位的数据，以32字为单位的话最多就是256kb大小的数据。于是摄像头只能设置为320x240大小。并且由于应用程序在SDRAM上跑，性能低下，以至于两秒钟才能出一张图片。。。而且SDRAM的带宽太小，拍照时还会时常说DMA下溢orz。。。据ST的手册推荐的话，应该利用DMA的双缓冲特性从而突破64k的限制，不过内核中并没有实现这一点。</p>
<h3 id="yaffs2"><a href="#yaffs2" class="headerlink" title="yaffs2"></a>yaffs2</h3><p>yaffs已经是一个相当老的文件系统了。。。它在几十上百MB的SLC上面跑到很欢快，但是并不太适用于MLC、TLC之类的几GB以上的大容量nand flash。不过对于uc-PC来说已经足够了。yaffs2适应于大页（2kb）的nand flash，yaffs适应于小页（512B）的nand flash。yaffs2声称它可工作在yaffs模式下面从而向前适应（但是我实验结果发现它并不如此）。</p>
<p>yaffs可以<a href="https://yaffs.net/get-yaffs" target="_blank" rel="noopener">从它官网上下载</a>。</p>
<h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><p>根据它的<a href="http://www.aleph1.co.uk/gitweb/?p=yaffs2.git;a=blob;f=README-linux;h=93cf4a14ce41deadff15868587ab48aa28701d95;hb=1f3d64d1d804fef6715126dead54bf30b176c67e" target="_blank" rel="noopener">README-linux</a>，使用以下命令去给内核打补丁：</p>
<pre><code>./patch-ker.sh  c m &lt;内核目录&gt;
</code></pre><p>然后内核配置时候就可以有yaffs的选项了：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/yaffs.jpeg" alt="yaffs配置" title="">
                </div>
                <div class="image-caption">yaffs配置</div>
            </figure></p>
<p>yaffs2已经可以支持4.9的内核了。不过在4.13内核上编译有问题，提示CURRENT_TIME这个宏未定义。发现这是因为Linux打算解决y2038的千年虫问题，需要改用别的计时方式。我直接用了current_kernel_time()代替了。</p>
<p>接下来要在内核里面添加nand flash的驱动。为方便起见，使用platform-nand驱动，即<code>CONFIG_MTD_NAND_PLATFORM</code>：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/ucpc5/yaffs2.jpeg" alt="platform nand驱动" title="">
                </div>
                <div class="image-caption">platform nand驱动</div>
            </figure></p>
<p>仿照<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/mach-omap1/board-h2.c" target="_blank" rel="noopener">arch/arm/mach-omap1/board-h2.c</a>，在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/mach-stm32/board-dt.c" target="_blank" rel="noopener">arch/arm/mach-stm32/board-dt.c</a>里面定义分区表以及驱动信息。</p>
<p>试探性的定义了三个分区：</p>
<pre><code class="c">/* 分区表 */
static struct mtd_partition stm32_nand_partitions[] = {
    {
        .name       = &quot;first&quot;,
        .offset     = 0,
        .size       = 128 * 1024,
        .mask_flags = MTD_WRITEABLE,    /* force read-only */
    },
    {
        .name       = &quot;second&quot;,
        .offset     = MTDPART_OFS_APPEND,
        .size       = 256 * 1024,
        .mask_flags = MTD_WRITEABLE,    /* force read-only */
    },
    {
        .name       = &quot;rootfs&quot;,
        .offset     = MTDPART_OFS_APPEND,
        .size       = 120 * SZ_1M,
    },
};
</code></pre>
<p>然后是platform data：</p>
<pre><code class="c">static struct platform_nand_data stm32_nand_platdata = {
    .chip = {
        // 分区表
        .nr_partitions = ARRAY_SIZE(stm32_nand_partitions),
        .partitions = stm32_nand_partitions,
    },
    .ctrl = {
        // 读写驱动程序
        .cmd_ctrl  = fmc_send_cmd,
        .dev_ready = fmc_read_rb,
    },
};
</code></pre>
<p>接着是platform device：</p>
<pre><code class="c">static struct platform_device stm32_nand_device = {
    .name = &quot;gen_nand&quot;,
    .dev  = {
        .platform_data = &amp;stm32_nand_platdata,
    },
};
</code></pre>
<p>最后，在模块构造函数里面注册platform device：</p>
<pre><code class="c">static void __init board_stm32_ucpc_init(void)
{
    printk(&quot;STM32 UCPC: nand platform device&quot;);
    platform_add_devices(stm32_devices, ARRAY_SIZE(stm32_devices));
}
</code></pre>
<p>启动之后，可以看到识别到三个分区：</p>
<pre><code>[    0.970000] nand: device found, Manufacturer ID: 0xec, Chip ID: 0xf1
[    0.980000] nand: Samsung NAND 128MiB 3,3V 8-bit
[    0.980000] nand: 128 MiB, SLC, erase size: 128 KiB, page size: 2048, OOB size: 64
[    0.990000] Scanning device for bad blocks
[    1.090000] Creating 3 MTD partitions on &quot;gen_nand.0&quot;:
[    1.100000] 0x000000000000-0x000000020000 : &quot;first&quot;
[    1.120000] 0x000000020000-0x000000060000 : &quot;second&quot;
[    1.150000] 0x000000060000-0x000007860000 : &quot;rootfs&quot;
</code></pre><h4 id="yaffs作为根文件系统"><a href="#yaffs作为根文件系统" class="headerlink" title="yaffs作为根文件系统"></a>yaffs作为根文件系统</h4><p>查看dmesg，可以看到有<code>Creating xxx MTD partitions on xxx</code>的信息。根据它出现的<strong>时间先后顺序</strong>，这些块设备依次形成<code>/dev/mtdblock0</code>、<code>/dev/mtdblock1</code>、<code>/dev/mtdblock2</code>等等。将含有rootfs的mtd分区传参给内核。</p>
<p>但是在这之前先得将rootfs烧录进nand flash。我使用了最简单的方法：先uboot通过tftp启动一个跑在SDRAM上的内核，挂载mtd分区<strong>以及nfs</strong>，然后从nfs上面拷贝rootfs到mtd分区里面。。。然后改写kernel command line，将mtd分区作为rootfs传参。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-04-27T15:20:06.959Z" itemprop="dateUpdated">2019-04-27 23:20:06</time>
</span><br>


        
        欢迎留言，大佬轻拍。。
        
    </div>
    
    <footer>
        <a href="https://hhuysqt.github.io">
            <img src="/img/avatar.jpg" alt="hhuysqt">
            hhuysqt
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ucpc/">ucpc</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://hhuysqt.github.io/ucpc5/&title=《uc-PC[5] Linux设备驱动配置》 — hhuysqt&pic=https://hhuysqt.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://hhuysqt.github.io/ucpc5/&title=《uc-PC[5] Linux设备驱动配置》 — hhuysqt&source=uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，就地运行（XIP，全称execute in place）。
需要使能的功能有：网..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://hhuysqt.github.io/ucpc5/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《uc-PC[5] Linux设备驱动配置》 — hhuysqt&url=https://hhuysqt.github.io/ucpc5/&via=https://hhuysqt.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://hhuysqt.github.io/ucpc5/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/ucpc6/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">uc-PC[6] 构建rootfs</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/ucpc4/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">uc-PC[4] 小议“设备树”</h4>
      </a>
    </div>
  
</nav>



    








<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: 'hhuysqt',
            repo: 'hhuysqt.github.io',
            oauth: {
                client_id: 'f3accf3be337dcd6d61d',
                client_secret: 'af75b9e501d76dc85f1f0417d7307419df49aeec',
            },
        })
        gitment.render('comments')
    </script>
</section>













</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>hhuysqt &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://hhuysqt.github.io/ucpc5/&title=《uc-PC[5] Linux设备驱动配置》 — hhuysqt&pic=https://hhuysqt.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://hhuysqt.github.io/ucpc5/&title=《uc-PC[5] Linux设备驱动配置》 — hhuysqt&source=uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，就地运行（XIP，全称execute in place）。
需要使能的功能有：网..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://hhuysqt.github.io/ucpc5/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《uc-PC[5] Linux设备驱动配置》 — hhuysqt&url=https://hhuysqt.github.io/ucpc5/&via=https://hhuysqt.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://hhuysqt.github.io/ucpc5/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://hhuysqt.github.io/ucpc5/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
